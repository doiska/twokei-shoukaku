{"version":3,"sources":["../src/connectors/libs/index.ts","../src/Utils.ts","../src/Constants.ts","../package.json","../src/connectors/Connector.ts","../src/connectors/libs/Eris.ts","../src/connectors/libs/DiscordJS.ts","../src/connectors/libs/OceanicJS.ts","../src/guild/Connection.ts","../src/guild/Player.ts","../src/node/Node.ts","../src/node/Rest.ts","../src/Shoukaku.ts"],"sourcesContent":["export * from './Eris';\nexport * from './DiscordJS';\nexport * from './OceanicJS';\n","export type Constructor<T> = new (...args: any[]) => T;\n\n/**\n * Merge the default options to user input\n * @param def Default options\n * @param given User input\n * @returns Merged options\n */\nexport function mergeDefault<T extends { [key: string]: any }>(def: T, given: T): Required<T> {\n    if (!given) return def as Required<T>;\n    const defaultKeys: (keyof T)[] = Object.keys(def);\n\n    for (const key in given) {\n        if (defaultKeys.includes(key)) continue;\n        delete given[key];\n    }\n\n    for (const key of defaultKeys) {\n        if (def[key] === null || (typeof def[key] === 'string' && def[key].length === 0)) {\n            if (!given[key]) throw new Error(`${String(key)} was not found from the given options.`);\n        }\n\n        if (given[key] === null || given[key] === undefined) given[key] = def[key];\n    }\n\n    return given as Required<T>;\n}\n\n/**\n * Wait for a specific amount of time (timeout)\n * @param ms Time to wait in milliseconds\n * @returns A promise that resolves in x seconds\n */\nexport function wait(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import Info from '../package.json';\nimport { NodeOption, ShoukakuOptions } from './Shoukaku';\n\nexport enum State {\n    CONNECTING,\n    NEARLY,\n    CONNECTED,\n    RECONNECTING,\n    DISCONNECTING,\n    DISCONNECTED\n}\n\nexport enum VoiceState {\n    SESSION_READY,\n    SESSION_ID_MISSING,\n    SESSION_ENDPOINT_MISSING,\n    SESSION_FAILED_UPDATE\n}\n\nexport enum OpCodes {\n    PLAYER_UPDATE = 'playerUpdate',\n    PLAYER_RESTORE = 'playerRestore',\n    STATS = 'stats',\n    EVENT = 'event',\n    READY = 'ready'\n}\n\nexport enum Versions {\n    REST_VERSION = 4,\n    WEBSOCKET_VERSION = 4\n}\n\nexport const ShoukakuDefaults: ShoukakuOptions = {\n    resume: false,\n    resumeTimeout: 30,\n    reconnectTries: 3,\n    reconnectInterval: 5,\n    restTimeout: 60,\n    moveOnDisconnect: false,\n    userAgent: `${Info.name}bot/${Info.version} (${Info.repository.url})`,\n    structures: {},\n    voiceConnectionTimeout: 15\n};\n\nexport const NodeDefaults: NodeOption = {\n    name: 'Default',\n    url: '',\n    auth: '',\n    secure: false,\n    group: undefined\n};\n","{\n  \"name\": \"@twokei/shoukaku\",\n  \"version\": \"1.0.2\",\n  \"description\": \"Forked Shoukaku module with session dump & recovery\",\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/index.mjs\",\n  \"types\": \"dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.js\"\n    }\n  },\n  \"scripts\": {\n    \"build\": \"npm run build:ts && npm run build:docs\",\n    \"build:ts\": \"tsup --config tsup-config.json\",\n    \"build:docs\": \"typedoc --theme default --readme README.md --out docs/ --entryPointStrategy expand src/.\",\n    \"lint\": \"eslint --fix --ext .ts\",\n    \"prepare\": \"npm run build:ts\"\n  },\n  \"keywords\": [\n    \"bot\",\n    \"music\",\n    \"lavalink\",\n    \"api\",\n    \"discord\",\n    \"lavalink.js\",\n    \"discord.js\",\n    \"lavalink-api\"\n  ],\n  \"engines\": {\n    \"node\": \">=18.0.0\",\n    \"npm\": \">=7.0.0\"\n  },\n  \"author\": \"Saya\",\n  \"contributors\": [\n    {\n      \"name\": \"doiska\",\n      \"email\": \"me@doiska.dev\"\n    },\n    {\n      \"email\": \"blagochevk@mail.ru\",\n      \"name\": \"Kirill Blagochev\"\n    }\n  ],\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/doiska/twokei-shoukaku\"\n  },\n  \"dependencies\": {\n    \"ws\": \"^8.13.0\"\n  },\n  \"devDependencies\": {\n    \"@augu/eslint-config\": \"^4.0.1\",\n    \"@types/node\": \"^20.3.1\",\n    \"@types/node-fetch\": \"^2.6.4\",\n    \"@types/ws\": \"^8.5.5\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.59.11\",\n    \"@typescript-eslint/parser\": \"^5.59.11\",\n    \"eslint\": \"^8.42.0\",\n    \"tsup\": \"^6.7.0\",\n    \"typedoc\": \"^0.24.8\",\n    \"typescript\": \"^5.1.3\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  }\n}\n","import { mergeDefault } from '../Utils';\nimport { NodeDefaults } from '../Constants';\nimport { NodeOption, Shoukaku } from '../Shoukaku';\n\nexport interface ConnectorMethods {\n    sendPacket: any;\n    getId: any;\n}\n\nexport const AllowedPackets = [ 'VOICE_STATE_UPDATE', 'VOICE_SERVER_UPDATE' ];\n\nexport abstract class Connector {\n    protected readonly client: any;\n    protected manager: Shoukaku | null;\n\n    constructor(client: any) {\n        this.client = client;\n        this.manager = null;\n    }\n\n    public set(manager: Shoukaku): Connector {\n        this.manager = manager;\n        return this;\n    }\n\n    protected ready(nodes: NodeOption[]): void {\n        this.manager!.id = this.getId();\n        for (const node of nodes) this.manager!.addNode(mergeDefault(NodeDefaults, node));\n    }\n\n    protected raw(packet: any): void {\n        if (!AllowedPackets.includes(packet.t)) return;\n\n        const guildId = packet.d.guild_id;\n        const connection = this.manager!.connections.get(guildId);\n\n        if (!connection) return;\n        if (packet.t === 'VOICE_SERVER_UPDATE') {\n            connection.setServerUpdate(packet.d);\n            if (!connection.established) return;\n\n            const player = this.manager!.players.get(guildId);\n            if (!player) return;\n\n            player.sendServerUpdate().catch(error => this.manager!.on('error', error));\n            return;\n        }\n\n        const userId = packet.d.user_id;\n        if (userId !== this.manager!.id) return;\n\n        connection.setStateUpdate(packet.d);\n    }\n\n    abstract getId(): string;\n\n    abstract sendPacket(shardId: number, payload: any, important: boolean): void;\n\n    abstract listen(nodes: NodeOption[]): void;\n}\n","import { Connector } from '../Connector';\nimport { NodeOption } from '../../Shoukaku';\n\nexport class Eris extends Connector {\n    // sendPacket is where your library send packets to Discord Gateway\n    public sendPacket(shardId: number, payload: any, important: boolean): void {\n        return this.client.shards.get(shardId)?.sendWS(payload.op, payload.d, important);\n    }\n    // getId is a getter where the lib stores the client user (the one logged in as a bot) id\n    public getId(): string {\n        return this.client.user.id;\n    }\n    // Listen attaches the event listener to the library you are using\n    public listen(nodes: NodeOption[]): void {\n        // Only attach to ready event once, refer to your library for its ready event\n        this.client.once('ready', () => this.ready(nodes));\n        // Attach to the raw websocket event, this event must be 1:1 on spec with dapi (most libs implement this)\n        this.client.on('rawWS', (packet: any) => this.raw(packet));\n    }\n}\n","import { Connector } from '../Connector';\nimport { NodeOption } from '../../Shoukaku';\n\nexport class DiscordJS extends Connector {\n    // sendPacket is where your library send packets to Discord Gateway\n    public sendPacket(shardId: number, payload: any, important: boolean): void {\n        return this.client.ws.shards.get(shardId)?.send(payload, important);\n    }\n    // getId is a getter where the lib stores the client user (the one logged in as a bot) id\n    public getId(): string {\n        return this.client.user.id;\n    }\n    // Listen attaches the event listener to the library you are using\n    public listen(nodes: NodeOption[]): void {\n        // Only attach to ready event once, refer to your library for its ready event\n        this.client.once('ready', () => this.ready(nodes));\n        // Attach to the raw websocket event, this event must be 1:1 on spec with dapi (most libs implement this)\n        this.client.on('raw', (packet: any) => this.raw(packet));\n    }\n}\n","import { Connector } from '../Connector';\nimport { NodeOption } from '../../Shoukaku';\n\nexport class OceanicJS extends Connector {\n    // sendPacket is where your library send packets to Discord Gateway\n    public sendPacket(shardId: number, payload: any, important: boolean): void {\n        return this.client.shards.get(shardId)?.send(payload.op, payload.d, important);\n    }\n    // getId is a getter where the lib stores the client user (the one logged in as a bot) id\n    public getId(): string {\n        return this.client.user.id;\n    }\n    // Listen attaches the event listener to the library you are using\n    public listen(nodes: NodeOption[]): void {\n        // Only attach to ready event once, refer to your library for its ready event\n        this.client.once('ready', () => this.ready(nodes));\n        // Attach to the raw websocket event, this event must be 1:1 on spec with dapi (most libs implement this)\n        this.client.on('packet', (packet: any) => this.raw(packet));\n    }\n}\n","import { Node } from '../node/Node';\nimport { EventEmitter, once } from 'events';\nimport { State, VoiceState } from '../Constants';\nimport { Shoukaku, VoiceChannelOptions } from '../Shoukaku.js';\n\n/**\n * Represents the partial payload from a stateUpdate event\n */\nexport interface StateUpdatePartial {\n    channel_id?: string;\n    session_id?: string;\n    self_deaf: boolean;\n    self_mute: boolean;\n}\n\n/**\n * Represents the payload from a serverUpdate event\n */\nexport interface ServerUpdate {\n    token: string;\n    guild_id: string;\n    endpoint: string;\n}\n\n/**\n * Represents a connection to a Discord voice channel\n */\nexport class Connection extends EventEmitter {\n    /**\n     * The manager where this connection is on\n     */\n    public manager: Shoukaku;\n    /**\n     * ID of Guild that contains the connected voice channel\n     */\n    public guildId: string;\n    /**\n     * ID of the connected voice channel\n     */\n    public channelId: string | null;\n    /**\n     * ID of the Shard that contains the guild that contains the connected voice channel\n     */\n    public shardId: number;\n    /**\n     * Mute status in connected voice channel\n     */\n    public muted: boolean;\n    /**\n     * Deafen status in connected voice channel\n     */\n    public deafened: boolean;\n    /**\n     * ID of current session\n     */\n    public sessionId: string | null;\n    /**\n     * Region of connected voice channel\n     */\n    public region: string | null;\n    /**\n     * Connection state\n     */\n    public state: State;\n    /**\n     * Boolean that indicates if voice channel changed since initial connection\n     */\n    public moved: boolean;\n    /**\n     * Boolean that indicates if this instance is reconnecting\n     */\n    public reconnecting: boolean;\n    /**\n     * If this connection has been established once\n     */\n    public established: boolean;\n    /**\n     * Cached serverUpdate event from Lavalink\n     */\n    public serverUpdate: ServerUpdate | null;\n    /**\n     * Get node function to get new nodes\n     */\n    public getNode: (node: Map<string, Node>, connection: Connection) => Node | undefined;\n    /**\n     * @param manager The manager of this connection\n     * @param options The options to pass in connection creation\n     * @param options.guildId GuildId in which voice channel to connect to is located\n     * @param options.shardId ShardId in which the guild exists\n     * @param options.channelId ChannelId of voice channel to connect to\n     * @param options.deaf Optional boolean value to specify whether to deafen the current bot user\n     * @param options.mute Optional boolean value to specify whether to mute the current bot user\n     * @param options.getNode Optional move function for moving players around\n     */\n    constructor(manager: Shoukaku, options: VoiceChannelOptions) {\n        super();\n        this.manager = manager;\n        this.guildId = options.guildId;\n        this.channelId = options.channelId;\n        this.shardId = options.shardId;\n        this.muted = options.mute ?? false;\n        this.deafened = options.deaf ?? false;\n        this.sessionId = null;\n        this.region = null;\n        this.state = State.DISCONNECTED;\n        this.moved = false;\n        this.reconnecting = false;\n        this.established = false;\n        this.serverUpdate = null;\n        this.getNode = options.getNode!;\n    }\n\n    /**\n     * Set the deafen status for the current bot user\n     * @param deaf Boolean value to indicate whether to deafen or undeafen\n     * @defaultValue false\n     */\n    public setDeaf(deaf = false): void {\n        this.deafened = deaf;\n        this.sendVoiceUpdate();\n    }\n\n    /**\n     * Set the mute status for the current bot user\n     * @param mute Boolean value to indicate whether to mute or unmute\n     * @defaultValue false\n     */\n    public setMute(mute = false): void {\n        this.muted = mute;\n        this.sendVoiceUpdate();\n    }\n\n    /**\n     * Disconnect the current bot user from the connected voice channel\n     * @internal\n     */\n    public disconnect(): void {\n        this.channelId = null;\n        this.deafened = false;\n        this.muted = false;\n        this.removeAllListeners();\n        this.sendVoiceUpdate();\n        this.manager.connections.delete(this.guildId);\n        this.state = State.DISCONNECTED;\n        this.debug(`[Voice] -> [Node] & [Discord] : Connection Destroyed | Guild: ${this.guildId}`);\n    }\n\n    /**\n     * Connect the current bot user to a voice channel\n     * @internal\n     */\n    public async connect(): Promise<void> {\n        this.state = State.CONNECTING;\n        this.sendVoiceUpdate();\n        this.debug(`[Voice] -> [Discord] : Requesting Connection | Guild: ${this.guildId}`);\n\n        const controller = new AbortController();\n        const timeout = setTimeout(() => controller.abort(), this.manager.options.voiceConnectionTimeout * 1000);\n\n        try {\n            const [ status ] = await once(this, 'connectionUpdate', { signal: controller.signal });\n            if (status !== VoiceState.SESSION_READY) {\n                switch (status) {\n                    case VoiceState.SESSION_ID_MISSING: throw new Error('The voice connection is not established due to missing session id');\n                    case VoiceState.SESSION_ENDPOINT_MISSING: throw new Error('The voice connection is not established due to missing connection endpoint');\n                }\n            }\n\n            this.state = State.CONNECTED;\n        } catch (error: any) {\n            this.debug(`[Voice] </- [Discord] : Request Connection Failed | Guild: ${this.guildId}`);\n            if (error.name === 'AbortError') throw new Error(`The voice connection is not established in ${this.manager.options.voiceConnectionTimeout} seconds`);\n\n            throw error;\n        } finally {\n            clearTimeout(timeout);\n        }\n    }\n\n    /**\n     * Update Session ID, Channel ID, Deafen status and Mute status of this instance\n     *\n     * @param options.session_id ID of this session\n     * @param options.channel_id ID of currently connected voice channel\n     * @param options.self_deaf Boolean that indicates if the current bot user is deafened or not\n     * @param options.self_mute Boolean that indicates if the current bot user is muted or not\n     * @internal\n     */\n    public setStateUpdate(options: StateUpdatePartial): void {\n        const { session_id, channel_id, self_deaf, self_mute } = options;\n        if (this.channelId && (channel_id && this.channelId !== channel_id)) {\n            this.moved = true;\n            this.debug(`[Voice] <- [Discord] : Channel Moved | Old Channel: ${this.channelId} Guild: ${this.guildId}`);\n        }\n\n        this.channelId = channel_id || this.channelId;\n        if (!channel_id) {\n            this.state = State.DISCONNECTED;\n            this.debug(`[Voice] <- [Discord] : Channel Disconnected | Guild: ${this.guildId}`);\n        }\n\n        this.deafened = self_deaf;\n        this.muted = self_mute;\n        this.sessionId = session_id || null;\n        this.debug(`[Voice] <- [Discord] : State Update Received | Channel: ${this.channelId} Session ID: ${session_id} Guild: ${this.guildId}`);\n    }\n\n    /**\n     * Sets the server update data for this connection\n     * @internal\n     */\n    public setServerUpdate(data: ServerUpdate): void {\n        if (!data.endpoint) {\n            this.emit('connectionUpdate', VoiceState.SESSION_ENDPOINT_MISSING);\n            return;\n        }\n\n        if (!this.sessionId) {\n            this.emit('connectionUpdate', VoiceState.SESSION_ID_MISSING);\n            return;\n        }\n\n        if (this.region && !data.endpoint.startsWith(this.region)) {\n            this.moved = true;\n            this.debug(`[Voice] <- [Discord] : Voice Region Moved | Old Region: ${this.region} Guild: ${this.guildId}`);\n        }\n\n        this.region = data.endpoint.split('.').shift()?.replace(/[0-9]/g, '') || null;\n        this.serverUpdate = data;\n        this.emit('connectionUpdate', VoiceState.SESSION_READY);\n        this.debug(`[Voice] <- [Discord] : Server Update Received | Server: ${this.region} Guild: ${this.guildId}`);\n    }\n\n    /**\n     * Send voice data to discord\n     * @internal\n     */\n    private sendVoiceUpdate() {\n        this.send({ guild_id: this.guildId, channel_id: this.channelId, self_deaf: this.deafened, self_mute: this.muted });\n    }\n\n    /**\n     * Send data to Discord\n     * @param data The data to send\n     * @internal\n     */\n    private send(data: any): void {\n        this.manager.connector.sendPacket(this.shardId, { op: 4, d: data }, false);\n    }\n\n    /**\n     * Emits a debug log\n     * @internal\n     */\n    private debug(message: string): void {\n        this.manager.emit('debug', this.constructor.name, message);\n    }\n}\n","import { EventEmitter } from 'events';\nimport { Node } from '../node/Node';\nimport { Connection } from './Connection';\nimport { OpCodes, State } from '../Constants';\nimport { Exception, Track, TrackInfo, UpdatePlayerInfo, UpdatePlayerOptions } from '../node/Rest';\n\nexport type TrackEndReason = 'finished' | 'loadFailed' | 'stopped' | 'replaced' | 'cleanup';\nexport type PlayerEventType = 'TrackStartEvent' | 'TrackEndEvent' | 'TrackExceptionEvent' | 'TrackStuckEvent' | 'WebSocketClosedEvent';\n\n/**\n * Options when playing a new track\n */\nexport interface PlayOptions {\n    track: string;\n    options?: {\n        noReplace?: boolean;\n        pause?: boolean;\n        startTime?: number;\n        endTime?: number;\n        volume?: number;\n    },\n    info: TrackInfo;\n}\n\nexport interface ResumeOptions {\n    noReplace?: boolean;\n    pause?: boolean;\n    startTime?: number;\n    endTime?: number;\n}\n\nexport interface Band {\n    band: number;\n    gain: number;\n}\n\nexport interface KaraokeSettings {\n    level?: number;\n    monoLevel?: number;\n    filterBand?: number;\n    filterWidth?: number;\n}\n\nexport interface TimescaleSettings {\n    speed?: number;\n    pitch?: number;\n    rate?: number;\n}\n\nexport interface FreqSettings {\n    frequency?: number;\n    depth?: number;\n}\n\nexport interface RotationSettings {\n    rotationHz?: number;\n}\n\nexport interface DistortionSettings {\n    sinOffset?: number;\n    sinScale?: number;\n    cosOffset?: number;\n    cosScale?: number;\n    tanOffset?: number;\n    tanScale?: number;\n    offset?: number;\n    scale?: number;\n}\n\nexport interface ChannelMixSettings {\n    leftToLeft?: number;\n    leftToRight?: number;\n    rightToLeft?: number;\n    rightToRight?: number;\n}\n\nexport interface LowPassSettings {\n    smoothing?: number\n}\n\nexport interface PlayerEvent {\n    op: OpCodes.EVENT;\n    type: PlayerEventType;\n    guildId: string;\n}\n\nexport interface TrackStartEvent extends PlayerEvent {\n    type: 'TrackStartEvent';\n    track: Track;\n}\n\nexport interface TrackEndEvent extends PlayerEvent {\n    type: 'TrackEndEvent';\n    track: Track;\n    reason: TrackEndReason;\n}\n\nexport interface TrackStuckEvent extends PlayerEvent {\n    type: 'TrackStuckEvent';\n    track: Track;\n    thresholdMs: number;\n}\n\nexport interface TrackExceptionEvent extends PlayerEvent {\n    type: 'TrackExceptionEvent';\n    exception: Exception;\n}\n\nexport interface TrackStuckEvent extends PlayerEvent {\n    type: 'TrackStuckEvent';\n    thresholdMs: number;\n}\n\nexport interface WebSocketClosedEvent extends PlayerEvent {\n    type: 'WebSocketClosedEvent';\n    code: number;\n    byRemote: boolean;\n    reason: string;\n}\n\nexport interface PlayerUpdate {\n    op: OpCodes.PLAYER_UPDATE;\n    state: {\n        connected: boolean;\n        position?: number;\n        time: number;\n    };\n    guildId: string;\n}\n\nexport interface PlayerRestore {\n    op: OpCodes.PLAYER_RESTORE;\n    state: {\n        restored: boolean;\n        node: string;\n    };\n    guildId: string;\n}\n\nexport interface FilterOptions {\n    volume?: number;\n    equalizer?: Band[];\n    karaoke?: KaraokeSettings | null;\n    timescale?: TimescaleSettings | null;\n    tremolo?: FreqSettings | null;\n    vibrato?: FreqSettings | null;\n    rotation?: RotationSettings | null;\n    distortion?: DistortionSettings | null;\n    channelMix?: ChannelMixSettings | null;\n    lowPass?: LowPassSettings | null;\n}\n\nexport declare interface Player {\n    /**\n     * Emitted when the current playing track ends\n     * @eventProperty\n     */\n    on(event: 'end', listener: (reason: TrackEndEvent) => void): this;\n    /**\n     * Emitted when the current playing track gets stuck due to an error\n     * @eventProperty\n     */\n    on(event: 'stuck', listener: (data: TrackStuckEvent) => void): this;\n    /**\n     * Emitted when the current websocket connection is closed\n     * @eventProperty\n     */\n    on(event: 'closed', listener: (reason: WebSocketClosedEvent) => void): this;\n    /**\n     * Emitted when a new track starts\n     * @eventProperty\n     */\n    on(event: 'start', listener: (data: TrackStartEvent) => void): this;\n    /**\n     * Emitted when there is an error caused by the current playing track\n     * @eventProperty\n     */\n    on(event: 'exception', listener: (reason: TrackExceptionEvent) => void): this;\n    /**\n     * Emitted when the library manages to resume the player\n     * @eventProperty\n     */\n    on(event: 'resumed', listener: (player: Player) => void): this;\n    /**\n     * Emitted when a playerUpdate event is received from Lavalink\n     * @eventProperty\n     */\n    on(event: 'update', listener: (data: PlayerUpdate) => void): this;\n    /**\n     * Emitted when a playerRestore event received from Shoukaku\n     * @eventProperty\n     */\n    on(event: 'restore', listener: (data: PlayerRestore) => void): this;\n    once(event: 'end', listener: (reason: TrackEndEvent) => void): this;\n    once(event: 'stuck', listener: (data: TrackStuckEvent) => void): this;\n    once(event: 'closed', listener: (reason: WebSocketClosedEvent) => void): this;\n    once(event: 'start', listener: (data: TrackStartEvent) => void): this;\n    once(event: 'exception', listener: (reason: TrackExceptionEvent) => void): this;\n    once(event: 'resumed', listener: (player: Player) => void): this;\n    once(event: 'update', listener: (data: PlayerUpdate) => void): this;\n    once(event: 'restore', listener: (data: PlayerRestore) => void): this;\n    off(event: 'end', listener: (reason: TrackEndEvent) => void): this;\n    off(event: 'stuck', listener: (data: TrackStuckEvent) => void): this;\n    off(event: 'closed', listener: (reason: WebSocketClosedEvent) => void): this;\n    off(event: 'start', listener: (data: TrackStartEvent) => void): this;\n    off(event: 'exception', listener: (reason: TrackExceptionEvent) => void): this;\n    off(event: 'resumed', listener: (player: Player) => void): this;\n    off(event: 'update', listener: (data: PlayerUpdate) => void): this;\n    off(event: 'restore', listener: (data: PlayerRestore) => void): this;\n}\n\n/**\n * Wrapper object around Lavalink\n */\nexport class Player extends EventEmitter {\n    /**\n     * GuildId of this player\n     */\n    public readonly guildId: string;\n    /**\n     * Connection class that this player is bound on\n     */\n    public readonly connection: Connection;\n    /**\n     * Lavalink node this player is connected to\n     */\n    public node: Node;\n    /**\n     * ID of current track\n     */\n    public track: string | null;\n    /**\n     * Player info from Lavalink\n     */\n    public info: any | null;\n    /**\n     * Global volume of the player\n     */\n    public volume: number;\n    /**\n     * Pause status in current player\n     */\n    public paused: boolean;\n    /**\n     * Ping represents the number of milliseconds between heartbeat and ack. Could be `-1` if not connected\n     */\n    public ping: number;\n    /**\n     * Position in ms of current track\n     */\n    public position: number;\n    /**\n     * Filters on current track\n     */\n    public filters: FilterOptions;\n    /**\n     * @param node An instance of Node (Lavalink API wrapper)\n     * @param connection An instance of connection class\n     */\n    constructor(node: Node, connection: Connection) {\n        super();\n        this.guildId = connection.guildId;\n        this.connection = connection;\n        this.node = node;\n        this.track = null;\n        this.volume = 100;\n        this.info = null;\n        this.paused = false;\n        this.position = 0;\n        this.ping = 0;\n        this.filters = {};\n    }\n\n    public get playerData(): UpdatePlayerInfo {\n        return {\n            guildId: this.guildId,\n            playerOptions: {\n                encodedTrack: this.track,\n                position: this.position,\n                paused: this.paused,\n                filters: this.filters,\n                info: this.info,\n                voice: {\n                    token: this.connection.serverUpdate!.token,\n                    endpoint: this.connection.serverUpdate!.endpoint,\n                    sessionId: this.connection.sessionId!\n                },\n                volume: this.volume\n            }\n        };\n    }\n\n    /**\n     * Move player to another node. Auto disconnects when the node specified is not found\n     * @param name\n     */\n    public async move(name?: string): Promise<void> {\n        try {\n            const node = this.node.manager.nodes.get(name!) || this.connection.getNode(this.connection.manager.nodes, this.connection);\n            if (!node) throw new Error('No node available to move to');\n            if (node.state !== State.CONNECTED) throw new Error('Tried to move to a node that is not connected');\n            if (node.name === this.node.name) throw new Error('Tried to move to the same node where the current player is connected on');\n\n            await this.destroyPlayer();\n            this.node = node;\n            this.node.players.set(this.guildId, this);\n\n            await this.resume();\n        } catch (error) {\n            this.connection.disconnect();\n            await this.destroyPlayer(true);\n            throw error;\n        }\n    }\n\n    /**\n     * Destroys the player in remote lavalink side\n     */\n    public async destroyPlayer(clean: boolean = false): Promise<void> {\n        this.node.players.delete(this.guildId);\n\n        if (clean) this.clean();\n        await this.node.rest.destroyPlayer(this.guildId);\n    }\n\n    /**\n     * Play a new track\n     * @param playable Options for playing this track\n     */\n    public async playTrack(playable: PlayOptions): Promise<void> {\n        const playerOptions: UpdatePlayerOptions = {\n            encodedTrack: playable.track,\n            info: playable.info\n        };\n\n        if (playable.options) {\n            const { pause, startTime, endTime, volume } = playable.options;\n            if (pause) playerOptions.paused = pause;\n            if (startTime) playerOptions.position = startTime;\n            if (endTime) playerOptions.endTime = endTime;\n            if (volume) playerOptions.volume = volume;\n        }\n\n        this.track = playable.track;\n        this.info = playable.info;\n\n        if (playerOptions.paused) this.paused = playerOptions.paused;\n        if (playerOptions.position) this.position = playerOptions.position;\n        if (playerOptions.volume) this.volume = playerOptions.volume;\n\n        await this.node.rest.updatePlayer({\n            guildId: this.guildId,\n            noReplace: playable.options?.noReplace ?? false,\n            playerOptions\n        });\n    }\n\n    /**\n     * Stop the currently playing track\n     */\n    public async stopTrack(): Promise<void> {\n        this.position = 0;\n\n        await this.node.rest.updatePlayer({\n            guildId: this.guildId,\n            playerOptions: { encodedTrack: null, info: null }\n        });\n    }\n\n    /**\n     * Pause or unpause the currently playing track\n     * @param paused Boolean value to specify whether to pause or unpause the current bot user\n     */\n    public async setPaused(paused = true): Promise<void> {\n        this.paused = paused;\n        await this.node.rest.updatePlayer({\n            guildId: this.guildId,\n            playerOptions: { paused: paused }\n        });\n    }\n\n    /**\n     * Seek to a specific time in the currently playing track\n     * @param position Position to seek to in milliseconds\n     */\n    public async seekTo(position: number): Promise<void> {\n        this.position = position;\n        await this.node.rest.updatePlayer({\n            guildId: this.guildId,\n            playerOptions: { position: position  }\n        });\n    }\n\n    /**\n     * Sets the global volume of the player\n     * @param volume Target volume 0-1000\n     */\n    public async setGlobalVolume(volume: number): Promise<void> {\n        this.volume = volume;\n        await this.node.rest.updatePlayer({\n            guildId: this.guildId,\n            playerOptions: { volume: this.volume  }\n        });\n    }\n\n    /**\n     * Sets the filter volume of the player\n     * @param volume Target volume 0.0-5.0\n     */\n    public async setFilterVolume(volume: number): Promise<void> {\n        this.filters.volume = volume;\n        await this.setFilters(this.filters);\n    }\n    /**\n     * Change the equalizer settings applied to the currently playing track\n     * @param equalizer An array of objects that conforms to the Bands type that define volumes at different frequencies\n     */\n    public async setEqualizer(equalizer: Band[]): Promise<void> {\n        this.filters.equalizer = equalizer;\n        await this.setFilters(this.filters);\n    }\n\n    /**\n     * Change the karaoke settings applied to the currently playing track\n     * @param karaoke An object that conforms to the KaraokeSettings type that defines a range of frequencies to mute\n     */\n    public async setKaraoke(karaoke?: KaraokeSettings): Promise<void> {\n        this.filters.karaoke = karaoke || null;\n        await this.setFilters(this.filters);\n    }\n\n    /**\n     * Change the timescale settings applied to the currently playing track\n     * @param timescale An object that conforms to the TimescaleSettings type that defines the time signature to play the audio at\n     */\n    public async setTimescale(timescale?: TimescaleSettings): Promise<void> {\n        this.filters.timescale = timescale || null;\n        await this.setFilters(this.filters);\n    }\n\n    /**\n     * Change the tremolo settings applied to the currently playing track\n     * @param tremolo An object that conforms to the FreqSettings type that defines an oscillation in volume\n     */\n    public async setTremolo(tremolo?: FreqSettings): Promise<void> {\n        this.filters.tremolo = tremolo || null;\n        await this.setFilters(this.filters);\n    }\n\n    /**\n     * Change the vibrato settings applied to the currently playing track\n     * @param vibrato An object that conforms to the FreqSettings type that defines an oscillation in pitch\n     */\n    public async setVibrato(vibrato?: FreqSettings): Promise<void> {\n        this.filters.vibrato = vibrato || null;\n        await this.setFilters(this.filters);\n    }\n\n    /**\n     * Change the rotation settings applied to the currently playing track\n     * @param rotation An object that conforms to the RotationSettings type that defines the frequency of audio rotating round the listener\n     */\n    public async setRotation(rotation?: RotationSettings): Promise<void> {\n        this.filters.rotation = rotation || null;\n        await this.setFilters(this.filters);\n    }\n\n    /**\n     * Change the distortion settings applied to the currently playing track\n     * @param distortion An object that conforms to DistortionSettings that defines distortions in the audio\n     * @returns The current player instance\n     */\n    public async setDistortion(distortion: DistortionSettings): Promise<void> {\n        this.filters.distortion = distortion || null;\n        await this.setFilters(this.filters);\n    }\n\n    /**\n     * Change the channel mix settings applied to the currently playing track\n     * @param channelMix An object that conforms to ChannelMixSettings that defines how much the left and right channels affect each other (setting all factors to 0.5 causes both channels to get the same audio)\n     */\n    public async setChannelMix(channelMix: ChannelMixSettings): Promise<void> {\n        this.filters.channelMix = channelMix || null;\n        await this.setFilters(this.filters);\n    }\n\n    /**\n     * Change the low pass settings applied to the currently playing track\n     * @param lowPass An object that conforms to LowPassSettings that defines the amount of suppression on higher frequencies\n     */\n    public async setLowPass(lowPass: LowPassSettings): Promise<void> {\n        this.filters.lowPass = lowPass || null;\n        await this.setFilters(this.filters);\n    }\n\n    /**\n     * Change the all filter settings applied to the currently playing track\n     * @param filters An object that conforms to FilterOptions that defines all filters to apply/modify\n     */\n    public async setFilters(filters: FilterOptions): Promise<void> {\n        this.filters = filters;\n        await this.node.rest.updatePlayer({\n            guildId: this.guildId,\n            playerOptions: { filters: filters, info: this.info }\n        });\n    }\n\n    /**\n     * Clear all filters applied to the currently playing track\n     */\n    public clearFilters(): Promise<void> {\n        return this.setFilters({\n            volume: 1,\n            equalizer: [],\n            karaoke: null,\n            timescale: null,\n            tremolo: null,\n            vibrato: null,\n            rotation: null,\n            distortion: null,\n            channelMix: null,\n            lowPass: null,\n        });\n    }\n\n    /**\n     * Resumes the current track\n     * @param options An object that conforms to ResumeOptions that specify behavior on resuming\n     */\n    public async resume(options: ResumeOptions = {}): Promise<void> {\n        const data = this.playerData;\n\n        if (options.noReplace) data.noReplace = options.noReplace;\n        if (options.startTime) data.playerOptions.position = options.startTime;\n        if (options.endTime) data.playerOptions.position;\n        if (options.pause) data.playerOptions.paused = options.pause;\n\n        await this.update(data);\n        this.emit('resumed', this);\n    }\n\n    /**\n     * If you want to update the whole player yourself, sends raw update player info to lavalink\n     */\n    public async update(updatePlayer: UpdatePlayerInfo): Promise<void> {\n        const data = { ...updatePlayer, ...{ guildId: this.guildId, sessionId: this.node.sessionId! }};\n        await this.node.rest.updatePlayer(data);\n\n        if (updatePlayer.playerOptions) {\n            const options = updatePlayer.playerOptions;\n            if (options.encodedTrack) this.track = options.encodedTrack;\n            if (options.position) this.position = options.position;\n            if (options.paused) this.paused = options.paused;\n            if (options.filters) this.filters = options.filters;\n            if (options.volume) this.volume = options.volume;\n            if (options.info) this.info = options.info;\n        }\n    }\n\n    /**\n     * Remove all event listeners on this instance\n     * @internal\n     */\n    public clean(): void {\n        this.removeAllListeners();\n        this.reset();\n    }\n\n    /**\n     * Reset the track, position and filters on this instance to defaults\n     * @internal\n     */\n    public reset(): void {\n        this.track = null;\n        this.volume = 100;\n        this.position = 0;\n        this.filters = {};\n    }\n\n    /**\n     * Sends server update to lavalink\n     * @internal\n     */\n    public async sendServerUpdate(): Promise<void> {\n        try {\n            const playerUpdate = {\n                guildId: this.guildId,\n                playerOptions: {\n                    info: this.info,\n                    voice: {\n                        token: this.connection.serverUpdate!.token,\n                        endpoint: this.connection.serverUpdate!.endpoint,\n                        sessionId: this.connection.sessionId!\n                    }\n                }\n            };\n\n            await this.node.rest.updatePlayer(playerUpdate);\n        } catch (error) {\n            if (!this.connection.established) throw error;\n            this.connection.disconnect();\n\n            await Promise.allSettled([ this.destroyPlayer(true) ]);\n        }\n    }\n\n    /**\n     * Handle player update data\n     */\n    public onPlayerUpdate(json: { state: { position: number, ping: number } }): void {\n        const { position, ping } = json.state;\n        this.position = position;\n        this.ping = ping;\n        this.emit('update', json);\n    }\n\n    /**\n     * Handle player events received from Lavalink\n     * @param json JSON data from Lavalink\n     * @internal\n     */\n    public onPlayerEvent(json: { type: string, track: Track }): void {\n        switch (json.type) {\n            case 'TrackStartEvent':\n                if (this.track) this.track = json.track.encoded;\n                this.emit('start', json);\n                break;\n            case 'TrackEndEvent':\n                this.emit('end', json);\n                break;\n            case 'TrackStuckEvent':\n                this.emit('stuck', json);\n                break;\n            case 'TrackExceptionEvent':\n                this.emit('exception', json);\n                break;\n            case 'WebSocketClosedEvent':\n                if (!this.connection.reconnecting) {\n                    if (!this.connection.moved)\n                        this.emit('closed', json);\n                    else\n                        this.connection.moved = false;\n                }\n\n                break;\n            default:\n                this.node.emit('debug', this.node.name, `[Player] -> [Node] : Unknown Player Event Type ${json.type} | Guild: ${this.guildId}`);\n        }\n    }\n}\n","import Websocket from 'ws';\nimport { Rest } from './Rest';\nimport { wait } from '../Utils';\nimport { EventEmitter } from 'events';\nimport { IncomingMessage } from 'http';\nimport { Player } from '../guild/Player';\nimport { NodeOption, PlayerDump, Shoukaku } from '../Shoukaku';\nimport { OpCodes, State, Versions } from '../Constants';\n\nexport interface NodeStats {\n    players: number;\n    playingPlayers: number;\n    memory: {\n        reservable: number;\n        used: number;\n        free: number;\n        allocated: number\n    };\n    frameStats: {\n        sent: number;\n        deficit: number;\n        nulled: number\n    };\n    cpu: {\n        cores: number;\n        systemLoad: number;\n        lavalinkLoad: number;\n    };\n    uptime: number;\n}\n\ntype NodeInfoVersion = {\n    semver: string;\n    major: number;\n    minor: number;\n    patch: number;\n    preRelease?: string;\n    build?: string;\n};\n\ntype NodeInfoGit = {\n    branch: string;\n    commit: string;\n    commitTime: number;\n};\n\ntype NodeInfoPlugin = {\n    name: string;\n    version: string;\n};\n\nexport type NodeInfo = {\n    version: NodeInfoVersion;\n    buildTime: number;\n    git: NodeInfoGit;\n    jvm: string;\n    lavaplayer: string;\n    sourceManagers: string[];\n    filters: string[];\n    plugins: NodeInfoPlugin[];\n};\n\nexport interface ResumableHeaders {\n    [key: string]: string;\n    'Client-Name': string;\n    'User-Agent': string;\n    'Authorization': string;\n    'User-Id': string;\n    'Session-Id': string;\n}\n\nexport interface NonResumableHeaders extends Omit<ResumableHeaders, 'Session-Id'> { }\n\n/**\n * Represents a Lavalink node\n */\nexport class Node extends EventEmitter {\n    /**\n     * Shoukaku class\n     */\n    public readonly manager: Shoukaku;\n    /**\n     * A map of guild ID to players\n     */\n    public readonly players: Map<string, Player>;\n    /**\n     * Lavalink rest API\n     */\n    public readonly rest: Rest;\n    /**\n     * Name of this node\n     */\n    public readonly name: string;\n    /**\n     * Group in which this node is contained\n     */\n    public readonly group?: string;\n    /**\n     * Websocket version this node will use\n     */\n    public readonly version: string;\n    /**\n     * URL of Lavalink\n     */\n    private readonly url: string;\n    /**\n     * Credentials to access Lavalink\n     */\n    private readonly auth: string;\n    /**\n     * The number of reconnects to Lavalink\n     */\n    public reconnects: number;\n    /**\n     * The state of this connection\n     */\n    public state: State;\n    /**\n     * Statistics from Lavalink\n     */\n    public stats: NodeStats | null;\n    /**\n     * Information about lavalink node\n    */\n    public info: NodeInfo | null;\n    /**\n     * Websocket instance\n     */\n    public ws: Websocket | null;\n    /**\n     * SessionId of this Lavalink connection (not to be confused with Discord SessionId)\n     */\n    public sessionId: string | undefined;\n    /**\n     * Boolean that represents if the node has initialized once\n     */\n    protected initialized: boolean;\n    /**\n     * Boolean that represents if this connection is destroyed\n     */\n    protected destroyed: boolean;\n    /**\n     * @param manager Shoukaku instance\n     * @param options Options on creating this node\n     * @param options.name Name of this node\n     * @param options.url URL of Lavalink\n     * @param options.auth Credentials to access Lavalnk\n     * @param options.secure Whether to use secure protocols or not\n     * @param options.group Group of this node\n     */\n    constructor(manager: Shoukaku, options: NodeOption) {\n        super();\n        this.manager = manager;\n        this.players = new Map();\n        this.rest = new (this.manager.options.structures.rest || Rest)(this, options);\n        this.name = options.name;\n        this.group = options.group;\n        this.version = `/v${Versions.WEBSOCKET_VERSION}`;\n        this.url = `${options.secure ? 'wss' : 'ws'}://${options.url}`;\n        this.auth = options.auth;\n        this.reconnects = 0;\n        this.state = State.DISCONNECTED;\n        this.stats = null;\n        this.info = null;\n        this.ws = null;\n        this.initialized = false;\n        this.destroyed = false;\n    }\n\n    /**\n     * Penalties for load balancing\n     * @returns Penalty score\n     * @internal @readonly\n     */\n    get penalties(): number {\n        let penalties = 0;\n        if (!this.stats) return penalties;\n\n        penalties += this.stats.players;\n        penalties += Math.round(Math.pow(1.05, 100 * this.stats.cpu.systemLoad) * 10 - 10);\n\n        if (this.stats.frameStats) {\n            penalties += this.stats.frameStats.deficit;\n            penalties += this.stats.frameStats.nulled * 2;\n        }\n\n        return penalties;\n    }\n\n    /**\n     * If we should clean this node\n     * @internal @readonly\n     */\n    private get shouldClean(): boolean {\n        return this.destroyed || this.reconnects + 1 >= this.manager.options.reconnectTries;\n    }\n\n    /**\n     * Connect to Lavalink\n     */\n    public connect(): void {\n        if (!this.manager.id) throw new Error('Don\\'t connect a node when the library is not yet ready');\n        if (this.destroyed) throw new Error('You can\\'t re-use the same instance of a node once disconnected, please re-add the node again');\n\n        this.state = State.CONNECTING;\n\n        const headers: NonResumableHeaders | ResumableHeaders = {\n            'Client-Name': this.manager.options.userAgent,\n            'User-Agent': this.manager.options.userAgent,\n            'Authorization': this.auth,\n            'User-Id': this.manager.id\n        };\n\n        const sessionId = [ ...this.manager.reconnectingPlayers.values() ].find((player: PlayerDump) => player.node.name === this.name)?.node.sessionId;\n\n        if (sessionId) headers['Session-Id'] = sessionId;\n        this.emit('debug', `[Socket] -> [${this.name}] : Connecting ${this.url}, Version: ${this.version}, Trying to resume? ${!!sessionId}`);\n        if (!this.initialized) this.initialized = true;\n\n        const url = new URL(`${this.url}${this.version}/websocket`);\n        this.ws = new Websocket(url.toString(), { headers } as Websocket.ClientOptions);\n        this.ws.once('upgrade', response => this.open(response));\n        this.ws.once('close', (...args) => this.close(...args));\n        this.ws.on('error', error => this.error(error));\n        this.ws.on('message', data => this.message(data).catch(error => this.error(error)));\n    }\n\n    /**\n     * Disconnect from lavalink\n     * @param code Status code\n     * @param reason Reason for disconnect\n     */\n    public disconnect(code: number, reason?: string): void {\n        if (this.destroyed) return;\n\n        this.destroyed = true;\n        this.state = State.DISCONNECTING;\n\n        if (this.ws)\n            this.ws.close(code, reason);\n        else\n            this.clean();\n    }\n\n    /**\n     * Handle connection open event from Lavalink\n     * @param response Response from Lavalink\n     * @internal\n     */\n    private open(response: IncomingMessage): void {\n        const resumed = response.headers['session-resumed'] === 'true';\n        this.emit('debug', `[Socket] <-> [${this.name}] : Connection Handshake Done! ${this.url} | Upgrade Headers Resumed: ${resumed}`);\n        this.reconnects = 0;\n        this.state = State.NEARLY;\n    }\n\n    /**\n     * Handle message from Lavalink\n     * @param message JSON message\n     * @internal\n     */\n    private async message(message: unknown): Promise<void> {\n        if (this.destroyed) return;\n        const json = JSON.parse(message as string);\n        if (!json) return;\n        this.emit('raw', json);\n        switch (json.op) {\n            case OpCodes.STATS:\n                this.emit('debug', `[Socket] <- [${this.name}] : Node Status Update | Server Load: ${this.penalties}`);\n                this.stats = json;\n                break;\n            case OpCodes.READY:\n                this.sessionId = json.sessionId;\n\n                this.state = State.CONNECTED;\n                this.emit('debug', `[Socket] -> [${this.name}] : Lavalink is ready! | Lavalink resume: ${json.resumed}`);\n\n                if (this.manager.options.resume) {\n                    await this.rest.updateSession(this.manager.options.resume, this.manager.options.resumeTimeout);\n                    this.emit('debug', `[Socket] -> [${this.name}] : Resuming configured!`);\n\n                    if (this.manager.reconnectingPlayers) {\n                        this.emit('debug', `[${this.name}] -> [Player] : Trying to re-create players from the last session`);\n                        await this.manager.restorePlayers(this);\n                        this.emit('debug', `[${this.name}] <-> [Player]: Session restore completed`);\n                    }\n                }\n\n                this.manager.connectingNodes.splice(this.manager.connectingNodes.indexOf(this.manager.connectingNodes.find(e => e.name === this.name)!), 1);\n\n                this.emit('ready', [ ...this.manager.reconnectingPlayers.values() ].filter(player => player.state?.node === this.name && player.state.restored)?.length ?? 0);\n                [ ...this.manager.reconnectingPlayers.values() ]?.filter(player => player.state?.node === this.name).forEach(dump => this.manager.reconnectingPlayers.delete(dump.options.guildId));\n\n                break;\n            case OpCodes.EVENT:\n            case OpCodes.PLAYER_UPDATE:\n                const player = this.players.get(json.guildId);\n                if (!player) return;\n                if (json.op === OpCodes.EVENT)\n                    player.onPlayerEvent(json);\n                else\n                    player.onPlayerUpdate(json);\n                break;\n            default:\n                this.emit('debug', `[Player] -> [Node] : Unknown Message OP ${json.op}`);\n        }\n    }\n\n    /**\n     * Handle closed event from lavalink\n     * @param code Status close\n     * @param reason Reason for connection close\n     */\n    private close(code: number, reason: unknown): void {\n        this.emit('debug', `[Socket] <-/-> [${this.name}] : Connection Closed, Code: ${code || 'Unknown Code'}`);\n        this.emit('close', code, reason);\n\n        if (this.shouldClean) {\n            this.manager.restorePlayers(this);\n            this.clean();\n        } else this.reconnect();\n    }\n\n    /**\n     * To emit error events easily\n     * @param error error message\n     */\n    public error(error: Error | unknown): void {\n        this.emit('error', error);\n    }\n\n    /**\n     * Destroys the websocket connection\n     * @internal\n     */\n    private destroy(move: boolean, count: number = 0): void {\n        this.ws?.removeAllListeners();\n        this.ws?.close();\n        this.ws = null;\n        this.state = State.DISCONNECTED;\n        if (!this.shouldClean) return;\n        this.destroyed = true;\n        this.emit('disconnect', move, count);\n    }\n\n    /**\n     * Cleans and moves players to other nodes if possible\n     * @internal\n     */\n    private async clean(): Promise<void> {\n        this.manager.connectingNodes.splice(this.manager.connectingNodes.indexOf(this.manager.connectingNodes.find(e => e.name === this.name)!), 1);\n\n        let move = this.manager.options.moveOnDisconnect;\n        if (!move) return this.destroy(false);\n        let count;\n\n        try {\n            count = await this.movePlayers();\n            move = count > 0;\n        } catch (error) {\n            this.error(error);\n        } finally {\n            this.destroy(move, count);\n        }\n    }\n\n    /**\n     * Reconnect to Lavalink\n     * @internal\n     */\n    private async reconnect(): Promise<void> {\n        if (this.state === State.RECONNECTING) return;\n        if (this.state !== State.DISCONNECTED) this.destroy(false);\n        this.state = State.RECONNECTING;\n        this.reconnects++;\n        this.emit('reconnecting', this.manager.options.reconnectTries - this.reconnects, this.manager.options.reconnectInterval);\n        this.emit('debug', `[Socket] -> [${this.name}] : Reconnecting in ${this.manager.options.reconnectInterval} seconds. ${this.manager.options.reconnectTries - this.reconnects} tries left`);\n        await wait(this.manager.options.reconnectInterval * 1000);\n        this.connect();\n    }\n\n    /**\n     * Tries to move the players to another node\n     * @internal\n     */\n    private async movePlayers(): Promise<number> {\n        const players = [ ...this.players.values() ];\n        const data = await Promise.allSettled(players.map(player => player.move()));\n        return data.filter(results => results.status === 'fulfilled').length;\n    }\n}\n","import { NodeOption } from '../Shoukaku';\nimport { Versions } from '../Constants';\nimport { FilterOptions } from '../guild/Player';\nimport { Node, NodeInfo, NodeStats } from './Node';\n\nexport type Severity = 'common' | 'suspicious' | 'fault';\n\nexport enum LoadType {\n    TRACK = 'track',\n    PLAYLIST = 'playlist',\n    SEARCH = 'search',\n    EMPTY = 'empty',\n    ERROR = 'error'\n}\n\nexport interface Track {\n    encoded: string;\n    info: TrackInfo;\n    pluginInfo: unknown;\n}\n\nexport interface TrackInfo {\n    identifier: string;\n    isSeekable: boolean;\n    author: string;\n    length: number;\n    isStream: boolean;\n    position: number;\n    title: string;\n    uri?: string;\n    sourceName?: string;\n    artworkUrl?: string;\n    isTrackUnavailable?: string;\n    isrc?: string;\n}\n\nexport interface Playlist {\n    encoded: string;\n    info: {\n        name: string;\n        selectedTrack: number;\n    };\n    pluginInfo: unknown;\n    tracks: Track[];\n}\n\nexport interface Exception {\n    message: string;\n    severity: Severity;\n    cause: string;\n}\n\nexport interface TrackResult {\n    loadType: LoadType.TRACK,\n    data: Track\n}\n\nexport interface PlaylistResult {\n    loadType: LoadType.PLAYLIST,\n    data: Playlist\n}\n\nexport interface SearchResult {\n    loadType: LoadType.SEARCH,\n    data: Track[]\n}\n\nexport interface EmptyResult {\n    loadType: LoadType.EMPTY,\n    data: {}\n}\n\nexport interface ErrorResult {\n    loadType: LoadType.ERROR,\n    data: Exception\n}\n\nexport type LavalinkResponse = TrackResult | PlaylistResult | SearchResult | EmptyResult | ErrorResult;\n\nexport interface Address {\n    address: string;\n    failingTimestamp: number;\n    failingTime: string;\n}\n\nexport interface RoutePlanner {\n    class: null | 'RotatingIpRoutePlanner' | 'NanoIpRoutePlanner' | 'RotatingNanoIpRoutePlanner' | 'BalancingIpRoutePlanner';\n    details: null | {\n        ipBlock: {\n            type: string;\n            size: string;\n        };\n        failingAddresses: Address[];\n        rotateIndex: string;\n        ipIndex: string;\n        currentAddress: string;\n        blockIndex: string;\n        currentAddressIndex: string;\n    };\n}\n\nexport interface LavalinkPlayerVoice {\n    token: string;\n    endpoint: string;\n    sessionId: string;\n    connected?: boolean;\n    ping?: number\n}\n\nexport interface LavalinkPlayerVoiceOptions extends Omit<LavalinkPlayerVoice, 'connected' | 'ping'> { }\n\nexport interface LavalinkPlayer {\n    guildId: string,\n    track?: Track,\n    volume: number;\n    paused: boolean;\n    voice: LavalinkPlayerVoice\n    filters: FilterOptions\n}\n\nexport interface UpdatePlayerOptions {\n    encodedTrack?: string | null;\n    identifier?: string;\n    position?: number;\n    endTime?: number;\n    volume?: number;\n    info?: TrackInfo | null;\n    paused?: boolean;\n    filters?: FilterOptions;\n    voice?: LavalinkPlayerVoiceOptions;\n}\n\nexport interface UpdatePlayerInfo {\n    guildId: string;\n    playerOptions: UpdatePlayerOptions;\n    noReplace?: boolean;\n}\n\nexport interface SessionInfo {\n    resumingKey?: string;\n    timeout: number;\n}\n\ninterface FetchOptions {\n    endpoint: string;\n    options: {\n        headers?: Record<string, string>;\n        params?: Record<string, string>;\n        method?: string;\n        body?: Record<string, unknown>;\n        [key: string]: unknown;\n    };\n}\n\ninterface FinalFetchOptions {\n    method: string;\n    headers: Record<string, string>;\n    signal: AbortSignal;\n    body?: string;\n}\n\n/**\n * Wrapper around Lavalink REST API\n */\nexport class Rest {\n    /**\n     * Node that initialized this instance\n     */\n    protected readonly node: Node;\n    /**\n     * URL of Lavalink\n     */\n    protected readonly url: string;\n    /**\n     * Credentials to access Lavalink\n     */\n    protected readonly auth: string;\n    /**\n     * Rest version to use\n     */\n    protected readonly version: string;\n    /**\n     * @param node An instance of Node\n     * @param options The options to initialize this rest class\n     * @param options.name Name of this node\n     * @param options.url URL of Lavalink\n     * @param options.auth Credentials to access Lavalnk\n     * @param options.secure Weather to use secure protocols or not\n     * @param options.group Group of this node\n     */\n    constructor(node: Node, options: NodeOption) {\n        this.node = node;\n        this.url = `${options.secure ? 'https' : 'http'}://${options.url}`;\n        this.version = `/v${Versions.REST_VERSION}`;\n        this.auth = options.auth;\n    }\n\n    protected get sessionId(): string {\n        return this.node.sessionId!;\n    }\n\n    /**\n     * Resolve a track\n     * @param identifier Track ID\n     * @returns A promise that resolves to a Lavalink response\n     */\n    public resolve(identifier: string): Promise<LavalinkResponse | undefined> {\n        const options = {\n            endpoint: '/loadtracks',\n            options: { params: { identifier }}\n        };\n\n        return this.fetch(options);\n    }\n\n    /**\n     * Decode a track\n     * @param track Encoded track\n     * @returns Promise that resolves to a track\n     */\n    public decode(track: string): Promise<Track | undefined> {\n        const options = {\n            endpoint: '/decodetrack',\n            options: { params: { track }}\n        };\n\n        return this.fetch<Track>(options);\n    }\n\n    /**\n     * Gets all the player with the specified sessionId\n     * @returns Promise that resolves to an array of Lavalink players\n     */\n    public async getPlayers(): Promise<LavalinkPlayer[]> {\n        const options = {\n            endpoint: `/sessions/${this.sessionId}/players`,\n            options: {}\n        };\n\n        return await this.fetch<LavalinkPlayer[]>(options) ?? [];\n    }\n\n    /**\n     * Gets all the player with the specified sessionId\n     * @returns Promise that resolves to an array of Lavalink players\n     */\n    public getPlayer(guildId: string): Promise<LavalinkPlayer | undefined> {\n        const options = {\n            endpoint: `/sessions/${this.sessionId}/players/${guildId}`,\n            options: {}\n        };\n\n        return this.fetch(options);\n    }\n\n    /**\n     * Updates a Lavalink player\n     * @param data SessionId from Discord\n     * @returns Promise that resolves to a Lavalink player\n     */\n    public updatePlayer(data: UpdatePlayerInfo): Promise<LavalinkPlayer | undefined> {\n        const options = {\n            endpoint: `/sessions/${this.sessionId}/players/${data.guildId}`,\n            options: {\n                method: 'PATCH',\n                params: { noReplace: data.noReplace?.toString() || 'false' },\n                headers: { 'Content-Type': 'application/json' },\n                body: data.playerOptions as Record<string, unknown>\n            }\n        };\n\n        return this.fetch<LavalinkPlayer>(options);\n    }\n\n    /**\n     * Deletes a Lavalink player\n     * @param guildId guildId where this player is\n     */\n    public async destroyPlayer(guildId: string): Promise<void> {\n        const options = {\n            endpoint: `/sessions/${this.sessionId}/players/${guildId}`,\n            options: { method: 'DELETE' }\n        };\n\n        await this.fetch(options);\n    }\n\n    /**\n     * Updates the session with a resume boolean and timeout\n     * @param resuming Whether resuming is enabled for this session or not\n     * @param timeout Timeout to wait for resuming\n     * @returns Promise that resolves to a Lavalink player\n     */\n    public updateSession(resuming?: boolean, timeout?: number): Promise<SessionInfo | undefined> {\n        const options = {\n            endpoint: `/sessions/${this.sessionId}`,\n            options: {\n                method: 'PATCH',\n                headers: { 'Content-Type': 'application/json' },\n                body: { resuming, timeout }\n            }\n        };\n\n        return this.fetch(options);\n    }\n\n    /**\n     * Gets the status of this node\n     * @returns Promise that resolves to a node stats response\n     */\n    public stats(): Promise<NodeStats | undefined> {\n        const options = {\n            endpoint: '/stats',\n            options: {}\n        };\n\n        return this.fetch(options);\n    }\n\n    /**\n     * Get routeplanner status from Lavalink\n     * @returns Promise that resolves to a routeplanner response\n     */\n    public getRoutePlannerStatus(): Promise<RoutePlanner | undefined> {\n        const options = {\n            endpoint: '/routeplanner/status',\n            options: {}\n        };\n\n        return this.fetch(options);\n    }\n\n    /**\n     * Release blacklisted IP address into pool of IPs\n     * @param address IP address\n     */\n    public async unmarkFailedAddress(address: string): Promise<void> {\n        const options = {\n            endpoint: '/routeplanner/free/address',\n            options: {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: { address }\n            }\n        };\n\n        await this.fetch(options);\n    }\n\n    /**\n     * Get Lavalink info\n     */\n    public getLavalinkInfo(): Promise<NodeInfo | undefined> {\n        const options = {\n            endpoint: '/info',\n            options: {\n                headers: { 'Content-Type': 'application/json' }\n            }\n        };\n\n        return this.fetch(options);\n    }\n\n    /**\n     * Make a request to Lavalink\n     * @param fetchOptions.endpoint Lavalink endpoint\n     * @param fetchOptions.options Options passed to fetch\n     * @internal\n     */\n    protected async fetch<T = unknown>(fetchOptions: FetchOptions) {\n        const { endpoint, options } = fetchOptions;\n        let headers = {\n            'Authorization': this.auth,\n            'User-Agent': this.node.manager.options.userAgent\n        };\n\n        if (options.headers) headers = { ...headers, ...options.headers };\n\n        const url = new URL(`${this.url}${this.version}${endpoint}`);\n\n        if (options.params) url.search = new URLSearchParams(options.params).toString();\n\n        const abortController = new AbortController();\n        const timeout = setTimeout(() => abortController.abort(), this.node.manager.options.restTimeout * 1000);\n\n        const method = options.method?.toUpperCase() || 'GET';\n\n        const finalFetchOptions: FinalFetchOptions = {\n            method,\n            headers,\n            signal: abortController.signal\n        };\n\n        if (![ 'GET', 'HEAD' ].includes(method) && options.body)\n            finalFetchOptions.body = JSON.stringify(options.body);\n\n        const request = await fetch(url.toString(), finalFetchOptions)\n            .finally(() => clearTimeout(timeout));\n\n        if (!request.ok) {\n            const response = await request\n                .json()\n                .catch(() => null);\n            if (!response?.message)\n                throw new Error(`Rest request failed with response code: ${request.status}`);\n            else\n                throw new Error(`Rest request failed with response code: ${request.status} | message: ${response.message}`);\n        }\n\n        try {\n            return await request.json() as T;\n        } catch { }\n    }\n}\n","import { Node } from './node/Node';\nimport { EventEmitter } from 'events';\nimport { Player } from './guild/Player';\nimport { Connection } from './guild/Connection';\nimport { Connector } from './connectors/Connector';\nimport { Constructor, mergeDefault } from './Utils';\nimport { Rest, UpdatePlayerOptions } from './node/Rest';\nimport { State, ShoukakuDefaults, OpCodes } from './Constants';\n\nexport interface Structures {\n    /**\n     * A custom structure that extends the Rest class\n     */\n    rest?: Constructor<Rest>;\n    /**\n     * A custom structure that extends the Player class\n     */\n    player?: Constructor<Player>;\n}\n\nexport interface NodeOption {\n    /**\n     * Name of this node\n     */\n    name: string;\n    /**\n     * URL of Lavalink\n     */\n    url: string;\n    /**\n     * Credentials to access Lavalink\n     */\n    auth: string;\n    /**\n     * Whether to use secure protocols or not\n     */\n    secure?: boolean;\n    /**\n     * Group of this node\n     */\n    group?: string;\n}\n\nexport interface ShoukakuOptions {\n    /**\n     * Whether to resume a connection on disconnect to Lavalink (Server Side) (Note: DOES NOT RESUME WHEN THE LAVALINK SERVER DIES)\n     */\n    resume?: boolean;\n    /**\n     * Time to wait before lavalink starts to destroy the players of the disconnected client\n     */\n    resumeTimeout?: number;\n    /**\n     * Number of times to try and reconnect to Lavalink before giving up\n     */\n    reconnectTries?: number;\n    /**\n     * Timeout before trying to reconnect\n     */\n    reconnectInterval?: number;\n    /**\n     * Time to wait for a response from the Lavalink REST API before giving up\n     */\n    restTimeout?: number;\n    /**\n     * Whether to move players to a different Lavalink node when a node disconnects\n     */\n    moveOnDisconnect?: boolean;\n    /**\n     * User Agent to use when making requests to Lavalink\n     */\n    userAgent?: string;\n    /**\n     * Custom structures for shoukaku to use\n     */\n    structures?: Structures;\n    /**\n     * Timeout before abort connection\n     */\n    voiceConnectionTimeout?: number;\n}\n\nexport interface VoiceChannelOptions {\n    guildId: string;\n    shardId: number;\n    channelId: string;\n    deaf?: boolean;\n    mute?: boolean;\n    getNode?: (node: Map<string, Node>, connection: Connection) => Node | undefined;\n}\n\nexport interface MergedShoukakuOptions {\n    resume: boolean;\n    resumeTimeout: number;\n    reconnectTries: number;\n    reconnectInterval: number;\n    restTimeout: number;\n    moveOnDisconnect: boolean;\n    userAgent: string;\n    structures: Structures;\n    voiceConnectionTimeout: number;\n}\n\nexport interface PlayerDump {\n    node: {\n        name: string;\n        group?: string;\n        sessionId: string;\n    };\n    options: {\n        guildId: string;\n        shardId: number;\n        channelId: string;\n        deaf?: boolean;\n        mute?: boolean;\n    };\n    player: UpdatePlayerOptions;\n    state?: {\n        restored: boolean;\n        node: string;\n    };\n    timestamp: number;\n}\n\nexport declare interface Shoukaku {\n    /**\n     * Emitted when reconnect tries are occurring and how many tries are left\n     * @eventProperty\n     */\n    on(event: 'reconnecting', listener: (name: string, reconnectsLeft: number, reconnectInterval: number) => void): this;\n    /**\n     * Emitted when data useful for debugging is produced\n     * @eventProperty\n     */\n    on(event: 'debug', listener: (name: string, info: string) => void): this;\n    /**\n     * Emitted when an error occurs\n     * @eventProperty\n     */\n    on(event: 'error', listener: (name: string, error: Error) => void): this;\n    /**\n     * Emitted when Shoukaku is ready to receive operations\n     * @eventProperty\n     */\n    on(event: 'ready', listener: (name: string, reconnected: number) => void): this;\n    /**\n     * Emitted when a websocket connection to Lavalink closes\n     * @eventProperty\n     */\n    on(event: 'close', listener: (name: string, code: number, reason: string) => void): this;\n    /**\n     * Emitted when a websocket connection to Lavalink disconnects\n     * @eventProperty\n     */\n    on(event: 'disconnect', listener: (name: string, moved: boolean, count: number) => void): this;\n    /**\n     * Emitted when a raw message is received from Lavalink\n     * @eventProperty\n     */\n    on(event: 'raw', listener: (name: string, json: unknown) => void): this;\n\n    /**\n     * Emitted after all players have been restored\n     * @eventProperty\n     */\n    on(event: 'restored', listener: (dump: PlayerDump[]) => void): this;\n    once(event: 'restored', listener: (dump: PlayerDump[]) => void): this;\n    once(event: 'reconnecting', listener: (name: string, reconnectsLeft: number, reconnectInterval: number) => void): this;\n    once(event: 'debug', listener: (name: string, info: string) => void): this;\n    once(event: 'error', listener: (name: string, error: Error) => void): this;\n    once(event: 'ready', listener: (name: string, reconnected: number) => void): this;\n    once(event: 'close', listener: (name: string, code: number, reason: string) => void): this;\n    once(event: 'disconnect', listener: (name: string, moved: boolean, count: number) => void): this;\n    once(event: 'raw', listener: (name: string, json: unknown) => void): this;\n\n    off(event: 'restored', listener: (dump: PlayerDump[]) => void): this;\n    off(event: 'reconnecting', listener: (name: string, reconnectsLeft: number, reconnectInterval: number) => void): this;\n    off(event: 'debug', listener: (name: string, info: string) => void): this;\n    off(event: 'error', listener: (name: string, error: Error) => void): this;\n    off(event: 'ready', listener: (name: string, reconnected: number) => void): this;\n    off(event: 'close', listener: (name: string, code: number, reason: string) => void): this;\n    off(event: 'disconnect', listener: (name: string, moved: boolean, count: number) => void): this;\n    off(event: 'raw', listener: (name: string, json: unknown) => void): this;\n}\n\n/**\n * Main Shoukaku class\n */\nexport class Shoukaku extends EventEmitter {\n    /**\n     * Discord library connector\n     */\n    public readonly connector: Connector;\n    /**\n     * Shoukaku options\n     */\n    public readonly options: MergedShoukakuOptions;\n    /**\n     * Connected Lavalink nodes\n     */\n    public readonly nodes: Map<string, Node>;\n    /**\n     * Voice connections being handled\n     */\n    public readonly connections: Map<string, Connection>;\n    /**\n     * Player dumps from previous session, waiting for reconnect\n     */\n    public reconnectingPlayers: Map<String, PlayerDump>;\n    /**\n     * Array of nodes waiting for connection\n     */\n    public connectingNodes: NodeOption[];\n    /**\n     * Shoukaku instance identifier\n     */\n    public id: string | null;\n    /**\n     * @param connector A Discord library connector\n     * @param nodes An array that conforms to the NodeOption type that specifies nodes to connect to\n     * @param options Options to pass to create this Shoukaku instance\n     * @param dumps\n     * @param options.resume Whether to resume a connection on disconnect to Lavalink (Server Side) (Note: DOES NOT RESUME WHEN THE LAVALINK SERVER DIES)\n     * @param options.resumeTimeout Time to wait before lavalink starts to destroy the players of the disconnected client\n     * @param options.reconnectTries Number of times to try and reconnect to Lavalink before giving up\n     * @param options.reconnectInterval Timeout before trying to reconnect\n     * @param options.restTimeout Time to wait for a response from the Lavalink REST API before giving up\n     * @param options.moveOnDisconnect Whether to move players to a different Lavalink node when a node disconnects\n     * @param options.userAgent User Agent to use when making requests to Lavalink\n     * @param options.structures Custom structures for shoukaku to use\n     */\n    constructor(connector: Connector, nodes: NodeOption[], options: ShoukakuOptions = {}, dumps: [String, PlayerDump][] = []) {\n        super();\n        this.connector = connector.set(this);\n        this.options = mergeDefault(ShoukakuDefaults, options);\n        this.nodes = new Map();\n        this.connections = new Map();\n        this.id = null;\n        this.connector.listen(nodes);\n        this.reconnectingPlayers = new Map<String, PlayerDump>(dumps);\n        this.connectingNodes = [];\n    }\n\n    /**\n     * Get a list of players\n     * @returns A map of guild IDs and players\n     * @readonly\n     */\n    get players(): Map<string, Player> {\n        const players = new Map();\n        for (const node of this.nodes.values()) {\n            for (const [ id, player ] of node.players) players.set(id, player);\n        }\n\n        return players;\n    }\n\n    /**\n     * Get dumped players data that you will need in case of a restart\n     * @returns A map of guild IDs and PlayerDump\n     * @readonly\n     */\n    get playersDump(): Map<string, PlayerDump> {\n        try {\n            const players = new Map() as Map<string, PlayerDump>;\n\n            for (const node of this.nodes.values()) {\n                for (const [ id, player ] of node.players) {\n                    if (!player.connection.serverUpdate?.token || !player.connection.serverUpdate?.endpoint) continue;\n\n                    players.set(id, {\n                        node: {\n                            name: player.node.name,\n                            group: player.node.group,\n                            sessionId: player.node.sessionId!\n                        },\n                        options: {\n                            guildId: player.connection.guildId,\n                            shardId: player.connection.shardId,\n                            channelId: player.connection.channelId!,\n                            deaf: player.connection.deafened,\n                            mute: player.connection.muted\n                        },\n                        player: player.playerData.playerOptions,\n                        timestamp: Date.now()\n                    });\n                }\n            }\n\n            return players;\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    /**\n     * Restore players from previous session\n     * @throws {Error} Will throw catched error if something went wrong\n     * @param node\n     */\n    async restorePlayers(node: Node): Promise<void> {\n        try {\n            const playerDumps = [ ...this.reconnectingPlayers.values() ].filter((player: PlayerDump) => player.node.name === node.name || player.node.group === node.group);\n\n            if (!playerDumps || playerDumps.length === 0) {\n                node.emit('debug', `[${node.name}] <- [Player] : Restore canceled due to missing data`);\n                return;\n            }\n\n            for (const dump of playerDumps) {\n\n                const isNodeAvailable = this.connectingNodes.filter(n => n?.group === node?.group).length > 0;\n\n                if (dump.timestamp + (this.options.reconnectInterval * 1000) < Date.now() || isNodeAvailable || node.state !== State.CONNECTED) {\n                    node.emit('debug', `[${node.name}] <- [Player/${dump.options.guildId}] : Couldn't restore player because session is expired or there are no suitable nodes available`);\n\n                    node.emit('raw', { op: OpCodes.PLAYER_RESTORE, state: { restored: false }, guildId: dump.options.guildId });\n                    node.emit('restore', { op: OpCodes.PLAYER_RESTORE, state: { restored: false }, guildId: dump.options.guildId });\n                    continue;\n                }\n\n                const player = await this.joinVoiceChannel({\n                    guildId: dump.options.guildId,\n                    shardId: dump.options.shardId,\n                    channelId: dump.options.channelId,\n                    deaf: dump.options.deaf ?? false,\n                    mute: dump.options.mute ?? false,\n                    getNode: () => {\n                        return node;\n                    }\n                });\n\n                dump.player.voice = {\n                    token: player.connection.serverUpdate!.token,\n                    endpoint: player.connection.serverUpdate!.endpoint,\n                    sessionId: player.connection.sessionId as string\n                };\n\n                player.connection.setStateUpdate({\n                    channel_id: dump.options.channelId,\n                    session_id: dump.player.voice?.sessionId,\n                    self_deaf: dump.options.deaf ?? false,\n                    self_mute: dump.options.mute ?? false\n                });\n\n                player.connection.setServerUpdate({\n                    token: dump.player.voice!.token,\n                    endpoint: dump.player.voice!.endpoint,\n                    guild_id: dump.options.guildId\n                });\n\n                await player.update({ guildId: dump.options.guildId, playerOptions: dump.player });\n                node.emit('debug', `[${node.name}] <- [Player] : Restored session \"${dump.options.guildId}\"`);\n\n                dump.state = { restored: true, node: node.name };\n                node.emit('raw', { op: OpCodes.PLAYER_RESTORE, state: dump.state, guildId: dump.options.guildId });\n                node.emit('restore', { op: OpCodes.PLAYER_RESTORE, state: dump.state, guildId: dump.options.guildId });\n            }\n\n            this.emit('restored', playerDumps);\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    /**\n     * Add a Lavalink node to the pool of available nodes\n     * @param options.name Name of this node\n     * @param options.url URL of Lavalink\n     * @param options.auth Credentials to access Lavalnk\n     * @param options.secure Whether to use secure protocols or not\n     * @param options.group Group of this node\n     */\n    public addNode(options: NodeOption): void {\n        const node = new Node(this, options);\n        node.on('debug', (...args) => this.emit('debug', node.name, ...args));\n        node.on('reconnecting', (...args) => this.emit('reconnecting', node.name, ...args));\n        node.on('error', (...args) => this.emit('error', node.name, ...args));\n        node.on('close', (...args) => this.emit('close', node.name, ...args));\n        node.on('ready', (...args) => this.emit('ready', node.name, ...args));\n        node.on('raw', (...args) => this.emit('raw', node.name, ...args));\n        node.once('disconnect', (...args) => this.clean(node, ...args));\n        node.connect();\n        this.nodes.set(node.name, node);\n        this.connectingNodes.push(options);\n    }\n\n    /**\n     * Remove a Lavalink node from the pool of available nodes\n     * @param name Name of the node\n     * @param reason Reason of removing the node\n     */\n    public removeNode(name: string, reason = 'Remove node executed'): void {\n        const node = this.nodes.get(name);\n        if (!node) throw new Error('The node name you specified doesn\\'t exist');\n        node.disconnect(1000, reason);\n    }\n\n    /**\n     * Joins a voice channel\n     * @param options.guildId GuildId in which the ChannelId of the voice channel is located\n     * @param options.shardId ShardId to track where this should send on sharded websockets, put 0 if you are unsharded\n     * @param options.channelId ChannelId of the voice channel you want to connect to\n     * @param options.deaf Optional boolean value to specify whether to deafen or undeafen the current bot user\n     * @param options.mute Optional boolean value to specify whether to mute or unmute the current bot user\n     * @param options.getNode Optional getter function if you have custom node resolving\n     * @returns The created player\n     * @internal\n     */\n    public async joinVoiceChannel(options: VoiceChannelOptions): Promise<Player> {\n        if (this.connections.has(options.guildId)) throw new Error('This guild already have an existing connection');\n        if (!options.getNode) options.getNode = this.getIdealNode.bind(this);\n\n        const connection = new Connection(this, options);\n        this.connections.set(connection.guildId, connection);\n\n        try {\n            await connection.connect();\n        } catch (error) {\n            this.connections.delete(options.guildId);\n            throw error;\n        }\n\n        try {\n            const node = options.getNode(this.nodes, connection);\n            if (!node) throw new Error('Can\\'t find any nodes to connect on');\n\n            const player = this.options.structures.player ? new this.options.structures.player(node, connection) : new Player(node, connection);\n            node.players.set(player.guildId, player);\n\n            try {\n                await player.sendServerUpdate();\n            } catch (error) {\n                node.players.delete(options.guildId);\n                throw error;\n            }\n\n            connection.established = true;\n            return player;\n        } catch (error) {\n            connection.disconnect();\n            throw error;\n        }\n    }\n\n    /**\n     * Leaves a voice channel\n     * @param guildId The id of the guild you want to delete\n     * @returns The destroyed / disconnected player or undefined if none\n     * @internal\n     */\n    public async leaveVoiceChannel(guildId: string): Promise<Player | undefined> {\n        const connection = this.connections.get(guildId);\n        if (connection) connection.disconnect();\n        const player = this.players.get(guildId);\n        if (player) await player.destroyPlayer(true);\n        return player;\n    }\n\n    /**\n     * Gets the Lavalink node the least penalty score\n     * @returns A Lavalink node or undefined if there are no nodes ready\n     */\n    public getIdealNode(): Node | undefined {\n        return [ ...this.nodes.values() ]\n            .filter(node => node.state === State.CONNECTED)\n            .sort((a, b) => a.penalties - b.penalties)\n            .shift();\n    }\n\n    /**\n     * Cleans the disconnected lavalink node\n     * @param node The node to clean\n     * @param args Additional arguments for Shoukaku to emit\n     * @returns A Lavalink node or undefined\n     * @internal\n     */\n    private clean(node: Node, ...args: unknown[]): void {\n        node.removeAllListeners();\n        this.nodes.delete(node.name);\n        this.emit('disconnect', node.name, ...args);\n    }\n}\n"],"mappings":"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","names":["State","VoiceState","OpCodes","Versions","EventEmitter","EventEmitter","LoadType","EventEmitter","EventEmitter","player","EventEmitter","EventEmitter"]}